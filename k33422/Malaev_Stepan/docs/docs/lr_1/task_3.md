# Задание 3

## Листинг кода

`config.py`

```python
HOST = '127.0.0.1'
PORT = 8080
```

`index.html`

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Hello, world!</title>
</head>
<body>
Hello, world!
</body>
</html>
```

`server.py`

```python
import socket

from config import HOST, PORT

with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    s.bind((HOST, PORT))
    s.listen(1)
    while True:
        conn, addr = s.accept()
        print('Connected by', addr)
        
        with open('index.html', 'rb') as f:
            data = f.read()
        
        conn.sendall(
            b'HTTP/1.1 200 OK\n'
            b'Content-Type: text/html\n'
            b'Connection: close\n\n'
            + data
        )

# http://localhost:8080/
```

## Основные Моменты

- **Настройка Сокета**: Сервер настроен на прослушивание входящих соединений по адресу `127.0.0.1` и порту `8080`, что
  является типичной конфигурацией для разработки и тестирования локальных веб-приложений.

- **Обработка Запросов**: При подключении клиента сервер читает содержимое файла `index.html` и отправляет его клиенту в
  ответ, включая стандартный HTTP-заголовок, который информирует браузер о том, что следует ожидать HTML-контент.

- **HTML**: Пример включает базовую HTML-страницу с простым приветствием, демонстрирующую, как можно обслуживать
  статические веб-страницы.

- **HTTP-Ответ**: Сервер формирует полноценный HTTP-ответ, включая статусную строку (`HTTP/1.1 200 OK`), заголовки,
  указывающие на тип содержимого (`Content-Type: text/html`) и управление соединением (`Connection: close`), что
  является хорошей практикой для обеспечения корректного отображения содержимого в браузере.

- **Блокировка Сокета**: В реализации используется блокирующий сокет, что означает, что сервер обрабатывает подключения
  последовательно. Это упрощает код, но для обработки множества одновременных соединений потребовалась бы асинхронность
  или многопоточность.

- **Содержимое в Байтах**: Отправка данных клиенту производится в байтовом формате, что подчеркивает низкоуровневую
  работу с сетевыми соединениями в Python.